{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/solid-principles","result":{"data":{"post":{"slug":"/solid-principles","title":"SOLID Development Principles","date":"24.04.2024","tags":[{"name":"SOLID","slug":"solid"},{"name":"OOP","slug":"oop"},{"name":"Design Patterns","slug":"design-patterns"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SOLID Development Principles\",\n  \"date\": \"2024-04-24T00:00:00.000Z\",\n  \"slug\": \"/solid-principles\",\n  \"tags\": [\"SOLID\", \"OOP\", \"Design Patterns\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"SOLID Principles\"), mdx(\"p\", null, \"Split files up with folders. Split by feature (core, infrastructure, UI) or type of file (Model, Controller, Interfaces)\"), mdx(\"h5\", null, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"S\"), \"ingle responsibility principle\"), mdx(\"p\", null, \"A class should only have a single responsibility. Only changes to one part of the software's specification should affect the specification of the class\"), mdx(\"h5\", null, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"O\"), \"pen-closed principle\"), mdx(\"p\", null, \"Software entities should be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"open\"), \" for extension but \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"closed\"), \" to modification\"), mdx(\"h5\", null, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"L\"), \"iskov substitution principle\"), mdx(\"p\", null, \"Objects in a program should be replaceable with instances of their sub-types (child classes) with the programming continuing to function correctly. I.e. the calling functions and properties shouldn't change in the extension/child classes, but the integrated functionality should. \"), mdx(\"h5\", null, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"I\"), \"nterface segregation principle\"), mdx(\"p\", null, \"Many client-specific interfaces are better than one general-purpose interface\"), mdx(\"h5\", null, mdx(\"em\", {\n    parentName: \"h5\"\n  }, \"D\"), \"ependency inversion principle\"), mdx(\"p\", null, \"Components should depend upon abstractions not on concretions (concrete classes)\"), mdx(\"h2\", null, \"Single Responsibility Principle (SRP)\"), mdx(\"p\", null, \"What is a responsibility?\"), mdx(\"p\", null, \"Each responsibility is a different axis of change\"), mdx(\"p\", null, \"Examples include:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Persistance\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Logging\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Validation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Business Logic\")), mdx(\"p\", null, \"If two details are integrated into the same class this introduces tight coupling. Therefore, if either of these details need to change this will affect the other and the way the entire class is implemented.\"), mdx(\"p\", null, \"Cohesion\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Connection inside elements in classes\")), mdx(\"p\", null, \"Coupling\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Connection of classes to each other\")), mdx(\"h3\", null, \"Separation of Concerns\"), mdx(\"p\", null, \"Programs should be separated into distinct sections, each addressing a separate concern, or set of information that affects the program.\"), mdx(\"p\", null, \"Keep classes small, focused and testable\"), mdx(\"h2\", null, \"Open / Closed Principle (OCP)\"), mdx(\"p\", null, \"Software entities (classes, modules, function, etc). Should be open for extension, but closed for modification. \"), mdx(\"p\", null, \"It should be possible to change the behaviour of a method without editing its source code.\"), mdx(\"h3\", null, \"Open to extension\"), mdx(\"p\", null, \"New behaviour can be added in the future\"), mdx(\"p\", null, \"Code that is closed to extension has fixed behaviour\"), mdx(\"h3\", null, \"Closed to modification\"), mdx(\"p\", null, \"Changes to source or binary code are not required\"), mdx(\"p\", null, \"The only way to change the behaviour of code that is closed to extension is to change the code itself.\"), mdx(\"h5\", null, \"Why should it be closed to modification?\"), mdx(\"p\", null, \"Less likely to introduce bugs in code we don't touch or redeploy\"), mdx(\"p\", null, \"Less likely to break dependent code when we don't have to deploy updates\"), mdx(\"p\", null, \"Fewer conditionals in code that is open to extension\"), mdx(\"p\", null, \"Bug fixes are ok - exception to the principles rule\"), mdx(\"p\", null, \"Balance abstraction and concreteness\"), mdx(\"p\", null, \"Abstraction adds complexity\"), mdx(\"p\", null, \"Predict where variation is needed and apply abstraction as needed (pain driven development)\"), mdx(\"p\", null, \"\\\"new\\\" is glue\"), mdx(\"p\", null, \"Should be resistant to newing up instances of objects inside classes\"), mdx(\"p\", null, \"How can you predict future changes?\"), mdx(\"p\", null, \"Start concrete\"), mdx(\"p\", null, \"Modify the code the first time or two\"), mdx(\"p\", null, \"By the third modification, consider making the code open to extension\\nfor that axis of change\"), mdx(\"h3\", null, \"Typical approaches to OCP\"), mdx(\"p\", null, \"Examples:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class DoOneThing\\n{\\n    public void Execute()\\n    {\\n        Console.WriteLine(\\\"Hello, World!\\\");\\n    }\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Parameters\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class DoOneThing\\n{\\n    public void Execute(string message)\\n    {\\n        Console.WriteLine(message);\\n    }\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Inheritance\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class DoOneThing\\n{\\n    public virtual void Execute()\\n    {\\n        Console.WriteLine(\\\"Hello, World!\\\");\\n    }\\n}\\npublic class DoAnotherThing : DoOneThing\\n{\\n    public override void Execute()\\n    {\\n        Console.WriteLine(\\\"Goodbye, World!\\\");\\n    }\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Composition / Injection\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class DoOneThing\\n{\\n    private readonly MessageService _messageService;\\n\\n    public DoOneThing (MessageService messageService) \\n        => _messageService = messageService;\\n\\n    public virtual void Execute()\\n    {\\n        Console.WriteLine(messageService.GetMessage());\\n    }\\n}\\n\")))), mdx(\"p\", null, \"Prefer implementing new features in new classes.\"), mdx(\"p\", null, \"Design classes from scratch to suit problem at hand\"), mdx(\"p\", null, \"Nothing in current system depends on it (no dependencies)\"), mdx(\"p\", null, \"Can add behaviour without touching existing code\"), mdx(\"p\", null, \"Can follow SRP in the new class\"), mdx(\"p\", null, \"Can be unit-tested (even if the rest of the application can't be)\"), mdx(\"h3\", null, \"Key Takeaways\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Solve the problem first using simple, concrete code\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Identify the kinds of changes the application is likely to continue needing\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Modify code to be extensible along the axis of change you've identified\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Without the need to modify its source each time\")))), mdx(\"h1\", null, \"Liskov Substitution Principle (LSP)\"), mdx(\"p\", null, \"Sub-types must be substitutable for their base types\"), mdx(\"p\", null, \"LSP states that the IS-A relationship is insufficient and should be replaced with IS-SUBSTITUTABLE-FOR\"), mdx(\"h3\", null, \"Fixing LSP Violations\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Follow the \\\"Tell, Don't Ask\\\" principle\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Encapsulate the logic for a particular action inside of the class being called. Don't implement the logic in the calling class.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Minimise null checks with\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"C# features\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Guard clauses\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Null Object design pattern\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Follow ISP and be sure to fully implement interfaces\")), mdx(\"p\", null, \"IS-A - inheritance relationship\"), mdx(\"p\", null, \"HAS-A - parameter relationship\"), mdx(\"h3\", null, \"Key Takeaways\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sub-types must be substitutable for their base types\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ensure base type invariants are enforced\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Look for\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type checking\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Null checking\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"NotImplementedException\")))), mdx(\"h2\", null, \"Interface Segregation Principle (ISP)\"), mdx(\"p\", null, \"Clients should not be forced to depend on methods they do not use.\"), mdx(\"p\", null, \"Prefer small, cohesive interfaces to large, \\\"fat\\\" ones\"), mdx(\"p\", null, \"Violating ISP results in classes that depend on things they don't need. \"), mdx(\"h3\", null, \"What does interface mean in ISP?\"), mdx(\"p\", null, \"C# interface type/keyword\"), mdx(\"p\", null, \"Public (or accessible) interface of a class\"), mdx(\"p\", null, \"A type's interface in this context is whatever can be accessed by client code working with an instance of that type.\"), mdx(\"h3\", null, \"What's a client?\"), mdx(\"p\", null, \"In this context, the client is the code that is interacting with an instance of the interface. It's the calling code.\"), mdx(\"h3\", null, \"Splitting up large interfaces\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public interface ILargeInterface : SmallInterfaceOne, SmallInterfaceTwo\\n{\\n}\\n\")), mdx(\"p\", null, \"If you originally had all of the template code in the ILargeInterface and then split it down into the two smaller interface. Implementing those two small interfaces will give the ILargeInterface the same template and will allow the code that was originally implementing ILargeInterface to continue working. It is a non-breaking change.\"), mdx(\"h3\", null, \"Fixing ISP Violations\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Break up large interfaces into smaller ones\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Compose fat interfaces from smaller ones for backward compatibility\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To address large interfaces you don't control\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create a small, cohesive interface\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use the Adapter design pattern so your code can work with the Adapter.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Clients should own and define their interfaces\")), mdx(\"h3\", null, \"Where do interfaces live in our apps?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Client code should define and own interfaces it uses\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interfaces should be declared where both client code and implementations can access it\")), mdx(\"h3\", null, \"Key Takeaways\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Prefer small, cohesive interfaces to large, expansive ones\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Following ISP helps with SRP and LSP\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Break up large interfaces by using\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interface inheritance\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The Adapter design pattern\")))), mdx(\"h2\", null, \"Dependency Inversion Principle\"), mdx(\"p\", null, \"High-level modules should not depend on low-level modules. Both should depend on abstractions. \"), mdx(\"p\", null, \"Abstractions should not depend on details.\"), mdx(\"p\", null, \"Details should depend on abstractions.\"), mdx(\"h3\", null, \"Dependencies in C#\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"References required to compile\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"References required to run\")), mdx(\"p\", null, \"High Level\"), mdx(\"p\", null, \"More abstract\"), mdx(\"p\", null, \"Business rulres\"), mdx(\"p\", null, \"Process-oriented\"), mdx(\"p\", null, \"Furhter from input/output (i/o)\"), mdx(\"p\", null, \"Low Level\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Closer to I/O\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"Plumbing\\\" code\")), mdx(\"p\", null, \"Interacts with specific external systems and hardware\"), mdx(\"h3\", null, \"Abstractions in C#\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interfaces\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Abstract base classes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"Types you can't instantiate\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Abstractions shouldn't be couple to details\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Abstractions describe what\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Send a message\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Store a customer record\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Details specify how\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Send an SMTP email over port 25\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Serialise Customer to JSON and store in a text file\")))), mdx(\"h3\", null, \"Hidden Direct Dependencies\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Direct use of low level dependencies\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Static calls and \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"new\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cause pain\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tight coupling\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Difficult to isolate and unit test\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Duplication\")))), mdx(\"h3\", null, \"Explicit Dependencies Principle\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Your class shouldn't surprise clients with dependencies\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"List them up front, in the constructor\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Think of them as ingredients in a cooking recipe.\")), mdx(\"h3\", null, \"Key Takeaways\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Most classes should depend on abstractions, not implementation details\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Abstractions shouldn't leak details\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Classes should be explicit about their dependencies\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Client should inject dependencies when they create other classes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Structure your solutions to leverage dependency inversion\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"SOLID Principles Split files up with folders. Split by feature (core, infrastructure, UI) or type of file (Model, Controller, Interfaces) Sâ€¦","timeToRead":4,"banner":null}},"pageContext":{"slug":"/solid-principles","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["2744905544","3090400250","318001574"]}